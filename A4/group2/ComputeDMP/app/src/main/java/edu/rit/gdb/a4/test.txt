package edu.rit.gdb.a4;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.nio.file.Path;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONObject;
import org.neo4j.configuration.GraphDatabaseSettings;
import org.neo4j.dbms.api.DatabaseManagementService;
import org.neo4j.dbms.api.DatabaseManagementServiceBuilder;
import org.neo4j.graphdb.GraphDatabaseService;

public class ComputeDMP {

	public static void main(String[] args) throws Exception {
		final String neo4jFolder = args[0], jsonFile = args[1];
		try (BufferedReader reader = new BufferedReader(new FileReader(jsonFile))) {
			String line;
			while ((line = reader.readLine()) != null) {
				JSONObject obj = new JSONObject(line);
				String database = obj.getString("database");
				try (DatabaseManagementService serviceDb = getNeo4jConnection(neo4jFolder, database);) {
					GraphDatabaseService db = serviceDb.database(GraphDatabaseSettings.initial_default_database.defaultValue());

					// TODO Nodes will have either psi or psiest set (but not both). Compute the
					// ranks of the nodes using psi or psiest, descending, and using degrees when
					// psi/psiest are tied, also descending. This is stored in a rankc property.
					// Similarly, the rankd property is the rank of the node according to its
					// degree, descending. Both rankc and rankd must be realistic ranks. Finally,
					// the dmp property is the combination of both rankc and rankd for each node.

					System.out.println("=== Processing " + database + " ===");
					ComputeDMP(db);
				}
			}
		}
	}

	private static void ComputeDMP(GraphDatabaseService db) {
		System.out.println("ComputeDMP()");
		String cypher = """
			MATCH (n:Node)
			WITH n, COALESCE(n.psi, n.psiest) AS psi, COUNT {(n)--()} AS degree
			ORDER BY psi DESC, degree DESC, n.id ASC
			WITH psi, degree, collect(n) AS nodes
			WITH collect({psi: psi, degree: degree, nodes: nodes}) AS groups
			UNWIND range(0, size(groups) - 1) AS i
			WITH groups[i] AS group, i, reduce(sum=0, j IN range(0, i - 1) | sum + size(groups[j].nodes)) AS offset
			UNWIND group.nodes AS node
			WITH node, group, offset, size(group.nodes) AS groupSize
			WITH node, offset + (groupSize + 1) / 2.0 AS rankc
			SET node.rankc = rankc
		""";
		db.executeTransactionally(cypher);
	}

	private static DatabaseManagementService getNeo4jConnection(String neo4jFolder, String database) {
		DatabaseManagementServiceBuilder builder = new DatabaseManagementServiceBuilder(Path.of(neo4jFolder, database))
				// This is necessary when dealing with large transactions... does it work?
				.setConfig(GraphDatabaseSettings.keep_logical_logs, "false")
				.setConfig(GraphDatabaseSettings.preallocate_logical_logs, false)
				.setConfig(GraphDatabaseSettings.memory_transaction_database_max_size, 0l)
				// This cleans the transaction files every 5 secs.
				.setConfig(GraphDatabaseSettings.check_point_interval_time, Duration.ofSeconds(5l));
		DatabaseManagementService service = builder.build();
		registerShutdownHook(service);
		return service;
	}

	private static void registerShutdownHook(final DatabaseManagementService service) {
		// Registers a shutdown hook for the Neo4j instance so that it
		// shuts down nicely when the VM exits (even if you "Ctrl-C" the
		// running application).
		Runtime.getRuntime().addShutdownHook(new Thread() {
			@Override
			public void run() {
				service.shutdown();
			}
		});
	}
}
